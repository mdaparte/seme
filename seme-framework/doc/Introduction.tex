This document provides the Software Design Description for the Sequentially Executed Model Evaluation (SeMe) Framework version 1.0. The SeMe Framework decouples model development from I/O development for certain classes of discrete models. The model classes of interest are numerical models that are evaluated sequentially for each step along a discrete axis. Because most of these types of models are time-series models, so this document will use time-series models in most examples and descriptions. However, any model that is controlled by stepping a parameter along a discrete axis will work with this framework. To do this, the controlling parameter is divided into equal size steps, and the model is evaluated once per step. For unitless parameters, integer steps are used. For time series models, steps are in date/time format. And on other continuous axes, as long as the axis is divided into equal size bins, a step index can be calculated and used (such as depth along a bore hole).

For real time models, he data used is generally obtained in some way from physical measurements. For testing and development, historical data is usually extracted into a historian database or into data files. Unfortunately, real time data collection is hardly standardized â€“ even Supervisory Control and Data Acquisition (SCADA) systems are incredibly diverse, and frequently involve custom, one-off databases for data collection. Developing models that execute in real time is therefore complicated by the need to interface with the database; the I/O effort can quickly overwhelm the model development, and resulting models can end up tied to specific databases or requiring massive rework to move the model to a different system. The goal of the SeMe framework is to separate the model and I/O efforts by providing a messaging interface that models can use for their input and output while leaving the specific I/O drivers for someone else to program (SEP).

The controller makes a call to the SeMe Engine for each step, iteratively. Each of these calls runs first all the input tasks, then all the model tasks, and finally all the output tasks. The Java ExecutionService framework is used to run the tasks in thread pools, taking advantage of multiple cores as well as advances in thread management within the Java virtual machine (JVM). The Engine waits for all tasks of a specific type (input, model, or output) to complete before starting the next group. 